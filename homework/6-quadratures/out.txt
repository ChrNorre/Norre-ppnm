
int(sqrt(x))[0,1] = 2/3 = 0.666667 in 11168 calls to integrand
int(4*sqrt(1-x*x))[0,1] = pi = 3.14159 in 25748 calls to integrand

without CC,	 int(1/sqrt(x))[0,1] = 2 = 2 in 5131180 calls to integrand
via CC,		 int(1/sqrt(x))[0,1] = 2 = 2 in 14276 calls to integrand
without CC,	 int(ln(x)/sqrt(x))[0,1] = -4 = -4 in 26472532 calls to integrand
via CC,		 int(ln(x)/sqrt(x))[0,1] = -4 = -4 in 71808 calls to integrand

Digits of pi via int(4*sqrt(1-x*x))[0,1] = PI:
pi from memory = 3.141592653589793238462643383279502884197169399375105820
without CC,		  calls =   25748 	  => 3.1415926535897993332 	 |diff| = 6.2172e-15
with CC,		  calls =   30540 	  => 3.141592653589793116 	 |diff| = 0
with simple gsl,	  calls =      87 	  => 3.141592719906342257 	 |diff| = 6.6317e-08
with adaptive gsl,	  calls = dunno 	  => 3.1415926535902984895 	 |diff| = 5.0537e-13

Every routine can fairly easily get within machine epsilon of M_PI
With more time, it would be cool to make a plot with accuracy given to the integration along the x-axis,
and deviation from PI along the y-axis, for the different routines to see how fast each of them reach PI
